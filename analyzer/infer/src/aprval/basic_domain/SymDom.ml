open! IStd
open! Vocab
module F = Format
module L = Logging

module Allocsite = struct
  (* Allocsite * counter (current method) * caller (increment by caller) *)
  type t = InstrNode.t * int * int [@@deriving compare]

  let callee_counter = ref 0

  let pp fmt (node, callee_cnt, caller_cnt) =
    let loc = InstrNode.get_loc node in
    let instr_str =
      F.asprintf "%a" (Sil.pp_instr ~print_types:false Pp.text) (InstrNode.get_instr node)
      |> String.length
    in
    if Location.equal Location.dummy loc then
      match InstrNode.get_proc_name node with
      | Procname.Java mthd when Procname.Java.is_constructor mthd ->
          F.fprintf fmt "%s_%d_%d (%d)"
            (Procname.Java.get_simple_class_name mthd)
            callee_cnt caller_cnt instr_str
      | proc_name ->
          F.fprintf fmt "%s_%d_%d (%d)" (Procname.get_method proc_name) callee_cnt caller_cnt
            instr_str
    else F.fprintf fmt "%a_%d_%d (%d)" Location.pp_line loc callee_cnt caller_cnt instr_str


  let make node =
    callee_counter := !callee_counter + 1 ;
    (node, !callee_counter, 0)


  let is_const_extern (node, _, _) =
    String.is_prefix (InstrNode.get_proc_name node |> Procname.get_method) ~prefix:"APRVAL_CONST"


  let is_intlit (node, _, _) =
    String.is_prefix
      (InstrNode.get_proc_name node |> Procname.get_method)
      ~prefix:"APRVAL_CONST_INT"


  let is_floatlit (node, _, _) =
    String.is_prefix
      (InstrNode.get_proc_name node |> Procname.get_method)
      ~prefix:"APRVAL_CONST_FLOAT"


  let get_intlit (node, _, _) =
    let extern_node_name = InstrNode.get_proc_name node |> Procname.get_method in
    try
      if String.is_prefix extern_node_name ~prefix:"APRVAL_CONST_INT" then
        let n =
          List.hd_exn (List.rev (Str.split (Str.regexp "_") extern_node_name)) |> int_of_string
        in
        Some (IntLit.of_int n)
      else None
    with _ -> None


  let get_floatlit (node, _, _) =
    let extern_node_name = InstrNode.get_proc_name node |> Procname.get_method in
    try
      if String.is_prefix extern_node_name ~prefix:"APRVAL_CONST_FLOAT" then
        let f =
          List.hd_exn (List.rev (Str.split (Str.regexp "_") extern_node_name)) |> float_of_string
        in
        Some f
      else None
    with _ -> None


  let get_const allocsite =
    match (get_intlit allocsite, get_floatlit allocsite) with
    | Some i, _ ->
        Some (Const.Cint i)
    | _, Some f ->
        Some (Const.Cfloat f)
    | _ ->
        None


  let increment_by_call allocsite offset =
    if is_const_extern allocsite then allocsite
    else
      let node, callee_cnt, caller_cnt = allocsite in
      (node, callee_cnt, caller_cnt + offset)


  let get_typ ((node, _, _) as allocsite) =
    match InstrNode.get_instr node with
    | Sil.Call ((_, ret_typ), _, _, _, _) ->
        ret_typ
    | _ ->
        L.(die InternalError) "%a is not an allocsite generated by new instr" pp allocsite


  let get_proc_name (node, _, _) = InstrNode.get_proc_name node
end

module SymbolCore = struct
  type access = Field of Fieldname.t | Index of IntLit.t [@@deriving compare]

  type base = Global of Pvar.t * access | Param of Pvar.t [@@deriving compare]

  type t = base * access list [@@deriving compare]

  let pp_access fmt = function
    | Field fn ->
        F.fprintf fmt ".%s" (Fieldname.to_simplified_string fn)
    | Index i ->
        F.fprintf fmt "[%a]" IntLit.pp i


  let pp_base fmt = function
    | Global (pv, access) ->
        F.fprintf fmt "G$(%a%a)" (Pvar.pp Pp.text) pv pp_access access
    | Param pv ->
        F.fprintf fmt "P(%a)" (Pvar.pp Pp.text) pv


  let pp fmt (base, accesses) = F.fprintf fmt "$(%a%a)" pp_base base (Pp.seq pp_access) accesses

  (* sort to resolve pvar first *)
  (*
  let compare (base1, accs1) (base2, accs2) =
    let len1, len2 = (List.length accs1, List.length accs2) in
    if Int.equal len1 len2 then compare (base1, accs1) (base2, accs2)
    else if len1 < len2 then -1
    else 1
*)

  let equal = [%compare.equal: t]

  let equal_access = [%compare.equal: access]

  let sub_symbols (base, accesses) : t list =
    match List.rev accesses with
    | [] ->
        []
    | _ :: tl ->
        List.fold (List.rev tl)
          ~init:([(base, [])], [])
          ~f:(fun (acc, accesses') access ->
            let new_accesses = accesses' @ [access] in
            let new_subsymbol = (base, new_accesses) in
            (new_subsymbol :: acc, new_accesses))
        |> fst


  let is_pvar = function Param _, [] -> true | _ -> false

  let is_global = function Global _, _ -> true | _ -> false

  let is_symbol_of ?(include_gv = false) proc = function
    | Param base, _ -> (
      match Pvar.get_declaring_function base with
      | Some proc' ->
          Procname.equal proc proc'
      | _ ->
          false )
    | _ ->
        include_gv


  let make_global pv fn = (Global (pv, Field fn), [])

  let of_pvar pv = (Param pv, [])

  let append_field ~fn (base, accs) =
    if List.mem accs (Field fn) ~equal:equal_access then None else Some (base, accs @ [Field fn])


  let append_index ~index (base, accs) = (base, accs @ [Index index])

  let to_ap : t -> AccessExpr.t =
    let append_symbol_access aexpr = function
      | Field fn ->
          AccessExpr.append_access aexpr (AccessExpr.FieldAccess fn)
      | Index intlit ->
          AccessExpr.append_access aexpr
            (AccessExpr.ArrayAccess (AccessExpr.of_const (Cint intlit)))
    in
    function
    | Global (pv, access), accesses ->
        List.fold (access :: accesses) ~init:(AccessExpr.of_formal pv) ~f:append_symbol_access
    | Param pv, accesses ->
        List.fold accesses ~init:(AccessExpr.of_formal pv) ~f:append_symbol_access
end

module Symbol = struct
  include SymbolCore
  module Set = PrettyPrintable.MakePPSet (SymbolCore)
end

module SymExp = struct
  type t =
    | IntLit of IntLit.t
    | FloatLit of float
    | Symbol of Symbol.t
    | Extern of Allocsite.t (* Symbol counter *)
  [@@deriving compare]

  let pp fmt = function
    | IntLit intlit ->
        IntLit.pp fmt intlit
    | FloatLit flit ->
        F.fprintf fmt "%.16f" flit
    | Symbol s ->
        Symbol.pp fmt s
    | Extern allocsite ->
        F.fprintf fmt "ExVal %a" Allocsite.pp allocsite


  let equal = [%compare.equal: t]

  let of_intlit intlit : t = IntLit intlit

  let of_float flit : t = FloatLit flit

  let of_symbol symbol : t = Symbol symbol

  let make_extern node = Extern (Allocsite.make node)

  let make_const_extern = function
    | IntLit i ->
        Extern (InstrNode.dummy_of ("APRVAL_CONST_INT_" ^ IntLit.to_string i), 0, 0)
    | FloatLit flit ->
        Extern (InstrNode.dummy_of ("APRVAL_CONST_FLOAT_" ^ F.asprintf "%.16f" flit), 0, 0)
    | _ as s ->
        L.(die InternalError) "%a is not constant" pp s


  let is_const_extern = function
    | Extern allocsite ->
        Allocsite.is_const_extern allocsite
    | _ ->
        false


  let is_constant = function IntLit _ | FloatLit _ -> true | _ -> false

  let is_symbolic = function Symbol _ -> true | _ -> false

  let is_symbol_of ?(include_gv = false) proc = function
    | Symbol s ->
        Symbol.is_symbol_of ~include_gv proc s
    | _ ->
        false


  let get_sub_symbols = function
    | Symbol sh ->
        Symbol.sub_symbols sh |> List.filter ~f:(fun sh' -> not (Symbol.equal sh sh'))
    | _ ->
        []


  let add node x y =
    match (x, y) with
    | IntLit x, IntLit y ->
        IntLit (IntLit.add x y)
    | FloatLit f1, FloatLit f2 ->
        FloatLit (f1 +. f2)
    | _ ->
        make_extern node


  let sub node x y =
    match (x, y) with
    | IntLit x, IntLit y ->
        IntLit (IntLit.sub x y)
    | FloatLit f1, FloatLit f2 ->
        FloatLit (f1 -. f2)
    | _ ->
        if equal x y then IntLit (IntLit.of_int 0) else make_extern node


  let mult node x y =
    match (x, y) with
    | IntLit x, IntLit y ->
        IntLit (IntLit.mul x y)
    | FloatLit f1, FloatLit f2 ->
        FloatLit (f1 *. f2)
    | IntLit i, v | v, IntLit i ->
        if IntLit.iszero i then IntLit i else if IntLit.isone i then v else make_extern node
    | FloatLit f, v | v, FloatLit f ->
        if Float.equal f 0. then FloatLit 0. else if Float.equal f 1. then v else make_extern node
    | _ ->
        make_extern node


  let div node x y =
    match (x, y) with
    | IntLit x, IntLit y ->
        IntLit (IntLit.div x y)
    | FloatLit f1, FloatLit f2 ->
        FloatLit (f1 /. f2)
    | IntLit i, _ when IntLit.iszero i ->
        IntLit i
    | FloatLit f, _ when Float.equal f 0. ->
        FloatLit 0.
    | _ ->
        make_extern node


  let get_const = function
    | IntLit n ->
        Some (Const.Cint n)
    | FloatLit f ->
        Some (Const.Cfloat f)
    | Extern allocsite ->
        Allocsite.get_const allocsite
    | _ ->
        None


  let lt node x y =
    match (x, y) with
    | IntLit x, IntLit y ->
        if IntLit.lt x y then IntLit IntLit.one else IntLit IntLit.zero
    | FloatLit x, FloatLit y ->
        if Int.is_negative (Float.compare x y) then IntLit IntLit.one else IntLit IntLit.zero
    | _ ->
        make_extern node


  let lte node x y =
    match (x, y) with
    | (Symbol _, Symbol _ | Extern _, Extern _ | IntLit _, IntLit _ | FloatLit _, FloatLit _)
      when equal x y ->
        IntLit IntLit.one
    | _ ->
        make_extern node


  let append_ctx ~offset = function
    | Extern allocsite ->
        Extern (Allocsite.increment_by_call allocsite offset)
    | t ->
        t
end

module SymHeap = struct
  type t =
    | Null of (int[@compare.ignore])
    | Allocsite of Allocsite.t
    | Extern of Allocsite.t
    | String of string
    | Symbol of Symbol.t
    | Unknown
  [@@deriving compare]

  let equal = [%compare.equal: t]

  let pp fmt = function
    | Null cnt ->
        F.fprintf fmt "Null(%d)" cnt
    | Allocsite allocsite ->
        F.fprintf fmt "Allocsite %a" Allocsite.pp allocsite
    | Extern allocsite ->
        F.fprintf fmt "Extern %a" Allocsite.pp allocsite
    | String str ->
        F.fprintf fmt "String %s" str
    | Symbol s ->
        F.fprintf fmt "%a" Symbol.pp s
    | Unknown ->
        F.fprintf fmt "Unknown"


  let null_counter = ref 0

  let to_string x = F.asprintf "%a" pp x

  let make_allocsite node = Allocsite (Allocsite.make node)

  let make_extern node = Extern (Allocsite.make node)

  let make_const_extern = function
    | Null cnt ->
        Null cnt
    | String str ->
        Extern (InstrNode.dummy_of ("APRVAL_CONST_STRING_" ^ str), 0, 0)
    | _ as sh ->
        L.(die InternalError) "%a is not a constant heap" pp sh


  let is_const_extern = function
    | Extern allocsite ->
        Allocsite.is_const_extern allocsite
    | _ ->
        false


  let make_null () =
    Null
      ( null_counter := !null_counter + 1 ;
        !null_counter )


  let make_string str = String str

  let of_symbol symbol = Symbol symbol

  let unknown = Unknown

  let get_class_name_opt = function
    | Allocsite (node, _, _) -> (
      match InstrNode.get_instr node with
      | Sil.Call (_, Exp.Const (Const.Cfun procname), [(Exp.Sizeof {typ}, _)], _, _)
        when is_new procname -> (
        match typ.desc with Tstruct name -> Some name | _ -> None )
      | _ ->
          None )
    | _ ->
        None


  let get_sub_symbols = function
    | Symbol sh ->
        Symbol.sub_symbols sh |> List.map ~f:(fun sh -> Symbol sh)
    | _ ->
        []


  let is_symbolic = function Symbol _ -> true | _ -> false

  let is_unknown = function Unknown -> true | _ -> false

  let is_extern = function Extern _ -> true | _ -> false

  let is_null = function Null _ -> true | _ -> false

  let is_concrete = function Allocsite _ | String _ | Null _ -> true | _ -> false

  let is_constant = function String _ | Null _ -> true | _ -> false

  let is_allocsite = function Allocsite _ -> true | _ -> false

  let is_symbol_of ?(include_gv = false) proc = function
    | Symbol s ->
        Symbol.is_symbol_of ~include_gv proc s
    | _ ->
        false


  let append_ctx ~offset = function
    | Allocsite allocsite ->
        Allocsite (Allocsite.increment_by_call allocsite offset)
    | Extern allocsite ->
        Extern (Allocsite.increment_by_call allocsite offset)
    | _ as s ->
        s


  let add node x y =
    match (x, y) with
    | String x, String y ->
        String (x ^ y)
    | Null _, String y ->
        String ("null" ^ y)
    | String x, Null _ ->
        String (x ^ "null")
    | Null _, Null _ ->
        String "nullnull"
    | _ ->
        make_extern node
end

module LocCore = struct
  type t =
    | TempVar of Pvar.t
    | Var of Pvar.t
    | SymHeap of SymHeap.t
    | Field of t * Fieldname.t
    | Index of t * SymExp.t
  [@@deriving compare]

  let rec pp fmt = function
    | TempVar v ->
        F.fprintf fmt "(TempPvar) %a" Pvar.pp_value v
    | Var v ->
        F.fprintf fmt "(Pvar) %a" Pvar.pp_value v
    | SymHeap s ->
        F.fprintf fmt "(SymHeap) %a" SymHeap.pp s
    | Field (l, f) ->
        F.fprintf fmt "(Field) (%a).(%s)" pp l (Fieldname.to_simplified_string f)
    | Index (l, s) ->
        F.fprintf fmt "(Index) (%a)[%a]" pp l SymExp.pp s


  let equal = [%compare.equal: t]

  let append_index l ~index = Index (l, index)

  let append_field ~fn l = Field (l, fn)

  let of_pvar pv : t = if Pvar.is_frontend_tmp pv then TempVar pv else Var pv

  let is_temp = function TempVar _ -> true | _ -> false

  let is_rec ~f = function Index (l, _) -> f l | Field (l, _) -> f l | _ as l -> f l

  let is_symheap = function SymHeap _ -> true | _ -> false

  let is_heap = is_rec ~f:is_symheap

  (* check whether location is abstract *)
  let is_unknown = is_rec ~f:(function SymHeap sh -> SymHeap.is_unknown sh | _ -> false)

  let is_extern = is_rec ~f:(function SymHeap sh -> SymHeap.is_extern sh | _ -> false)

  let is_allocsite = is_rec ~f:(function SymHeap sh -> SymHeap.is_allocsite sh | _ -> false)

  let rec is_concrete = function
    | Var _ | TempVar _ ->
        true
    | SymHeap sh ->
        SymHeap.is_concrete sh
    | Field (l, _) ->
        is_concrete l
    | Index (l, _) ->
        is_concrete l


  let is_symbolic = is_rec ~f:(function SymHeap h -> SymHeap.is_symbolic h | _ -> false)

  let is_var = function Var _ | TempVar _ -> true | _ -> false

  let is_return = function Var pv -> Pvar.is_return pv | _ -> false

  let is_null = function SymHeap h -> SymHeap.is_null h | _ -> false

  let rec is_global = function
    | Var pv ->
        Pvar.is_global pv
    | SymHeap (SymHeap.Symbol s) ->
        Symbol.is_global s
    | Field (t, _) ->
        is_global t
    | Index (t, SymExp.Symbol s) ->
        is_global t || Symbol.is_global s
    | _ ->
        false


  let unknown = SymHeap SymHeap.unknown

  let make_extern node = SymHeap (SymHeap.make_extern node)

  let make_allocsite node = SymHeap (SymHeap.make_allocsite node)

  let make_null () = SymHeap (SymHeap.make_null ())

  let make_string str = SymHeap (SymHeap.make_string str)

  let to_symbol_opt : t -> Symbol.t option = function
    | Var pv ->
        Some (Symbol.of_pvar pv)
    | Field (Var pv, fn) when Pvar.is_global pv ->
        Some (Symbol.make_global pv fn)
    | Field (Var pv, fn) when Pvar.is_global pv ->
        Some (Symbol.make_global pv fn)
    | Field (SymHeap (Symbol s), fn) ->
        Symbol.append_field s ~fn
    | Index (SymHeap (Symbol s), SymExp.IntLit index) ->
        Some (Symbol.append_index s ~index)
    | Index (SymHeap (Symbol s), SymExp.Extern allocsite) -> (
      match Allocsite.get_intlit allocsite with
      | Some index ->
          Some (Symbol.append_index s ~index)
      | None ->
          None )
    | _ ->
        None


  let get_heap_opt = function
    | SymHeap sh | Field (SymHeap sh, _) | Index (SymHeap sh, _) ->
        Some sh
    | _ ->
        None


  let rec append_ctx ~offset = function
    | SymHeap sh ->
        SymHeap (SymHeap.append_ctx ~offset sh)
    | Field (l, fn) ->
        Field (append_ctx ~offset l, fn)
    | Index (l, index) ->
        Index (append_ctx l ~offset, index)
    | _ as l ->
        l


  let rec base_of = function Field (l, _) -> base_of l | Index (l, _) -> base_of l | _ as l -> l

  let to_ap = function
    | Var pv when Pvar.is_return pv ->
        Some (AccessExpr.of_formal pv)
    | Var pv | TempVar pv ->
        (* Local predicate *)
        Some (AccessExpr.of_pvar pv)
    | Field (Var pv, fn) when Pvar.is_global pv ->
        Some (AccessExpr.append_access (AccessExpr.of_formal pv) (AccessExpr.FieldAccess fn))
    | Field (Var pv, fn) ->
        Some (AccessExpr.append_access (AccessExpr.of_pvar pv) (AccessExpr.FieldAccess fn))
    | _ ->
        None


  let rec replace_heap ~src ~dst = function
    | SymHeap sh when SymHeap.equal sh src ->
        SymHeap dst
    | Field (l, fn) ->
        Field (replace_heap l ~src ~dst, fn)
    | Index (l, index) ->
        Index (replace_heap l ~src ~dst, index)
    | _ as l ->
        l


  let replace_by_map ~f = function
    | Field (l, fn) ->
        Field (f l, fn)
    | Index (l, e) ->
        Index (f l, e)
    | l ->
        f l
end

module Loc = struct
  include LocCore
  module Set = AbstractDomain.FiniteSet (LocCore)
  module Map = PrettyPrintable.MakePPMap (LocCore)
end

module ValCore = struct
  type t =
    | Vint of SymExp.t
    | Vheap of SymHeap.t
    | Vexn of t
    | Vextern of Procname.t * t list
    | Bot
    | Top
  [@@deriving compare]

  let compare_up_to_source x y =
    match (x, y) with Vheap (Null x'), Vheap (Null y') -> Int.compare x' y' | _ -> compare x y


  let rec pp fmt = function
    | Vint i ->
        F.fprintf fmt "(SymExp) %a" SymExp.pp i
    | Vheap h ->
        F.fprintf fmt "(SymHeap) %a" SymHeap.pp h
    | Vexn (Vheap h) ->
        F.fprintf fmt "(Exn) %a" SymHeap.pp h
    | Vextern (callee, args) ->
        F.fprintf fmt "(Extern) %s(%a)" (Procname.get_method callee) (Pp.seq pp ~sep:",") args
    | Bot ->
        F.fprintf fmt "Bot"
    | Top ->
        F.fprintf fmt "Top"
    | Vexn v ->
        L.(die InternalError) "Invalid exceptional value: %a@." pp v


  let equal = [%compare.equal: t]

  let equal_up_to_source x y =
    match (x, y) with Vheap (Null x'), Vheap (Null y') -> Int.equal x' y' | _ -> equal x y


  let bottom = Bot (* undefined *)

  let top = Top (* type is not resolved, error! *)

  let get_const = function Vint se -> SymExp.get_const se | _ -> None

  let is_bottom = function Bot -> true | _ -> false

  let is_top = function Top -> true | _ -> false

  let is_symbol_of ?(include_gv = false) proc = function
    | Vint s ->
        SymExp.is_symbol_of ~include_gv proc s
    | Vheap s ->
        SymHeap.is_symbol_of ~include_gv proc s
    | _ ->
        false


  let leq ~lhs ~rhs =
    match (lhs, rhs) with
    | Vint i1, Vint i2 ->
        SymExp.equal i1 i2
    | Vheap h1, Vheap h2 ->
        SymHeap.equal h1 h2
    | Bot, _ ->
        true
    | _, Top ->
        true
    | _ ->
        false


  let is_different_type x y =
    match (x, y) with
    | Vint _, Vheap _
    | Vint _, Vexn _
    | Vheap _, Vint _
    | Vheap _, Vexn _
    | Vexn _, Vint _
    | Vexn _, Vheap _ ->
        true
    | _ ->
        false


  let get_class_name_opt = function Vheap sh -> SymHeap.get_class_name_opt sh | _ -> None

  let resolve_callee_by_base callee this_value =
    match get_class_name_opt this_value with
    | Some class_name ->
        Procname.replace_class callee class_name
    | None ->
        callee


  let to_exn = function
    | Vheap sh ->
        Vexn (Vheap sh)
    | _ as v ->
        L.(die InternalError) "%a cannot be throwable" pp v


  let unwrap_exn = function
    | Vexn sh ->
        sh
    | _ as v ->
        raise (Unexpected (F.asprintf "%a is not throwable" pp v))


  let zero = Vint (SymExp.of_intlit IntLit.zero)

  let one = Vint (SymExp.of_intlit IntLit.one)

  (*
  let equal t1 t2 =
    match (t1, t2) with Vheap heap1, Vheap heap2 -> SymHeap.equal heap1 heap2 | _ -> equal t1 t2
    *)

  let make_allocsite node = Vheap (SymHeap.make_allocsite node)

  let make_int_extern node = Vint (SymExp.make_extern node)

  let make_heap_extern node = Vheap (SymHeap.make_extern node)

  let make_extern node typ =
    match Typ.(typ.desc) with
    | Tint _ | Tfloat _ ->
        make_int_extern node
    | Tptr _ | Tarray _ ->
        make_heap_extern node
    | _ ->
        top


  let make_null () = Vheap (SymHeap.make_null ())

  let make_string str = Vheap (SymHeap.make_string str)

  let make_const_extern = function
    | Vheap sheap when SymHeap.is_constant sheap ->
        Vheap (SymHeap.make_const_extern sheap)
    | Vint symexp when SymExp.is_constant symexp ->
        Vint (SymExp.make_const_extern symexp)
    | _ as v ->
        v


  let is_const_extern = function
    | Vheap sheap ->
        SymHeap.is_const_extern sheap
    | Vint symexp ->
        SymExp.is_const_extern symexp
    | _ ->
        false


  let unknown = Vheap SymHeap.unknown

  let npe = to_exn (make_string "APRVAL_RUNTIME_NullPointerException")

  let exn = to_exn (make_string "APRVAL_RUNTIME_Exception")

  let is_null = function Vheap symheap -> SymHeap.is_null symheap | _ -> false

  let is_heap = function Vheap _ -> true | _ -> false

  let is_int = function Vint _ -> true | _ -> false

  let is_extern = function Vheap (SymHeap.Extern _) | Vint (SymExp.Extern _) -> true | _ -> false

  let rec is_abstract = function
    | Vheap symheap ->
        SymHeap.is_unknown symheap
    | Top ->
        true
    | Bot ->
        true
    | Vextern (callee, _) when Procname.is_infer_undefined callee ->
        true
    | Vextern (_, args) ->
        List.exists args ~f:is_abstract
    | _ ->
        false


  let rec is_concrete = function
    | Vint symexp ->
        SymExp.is_constant symexp
    | Vheap symheap ->
        SymHeap.is_concrete symheap
    | Vexn t ->
        is_concrete t
    | _ ->
        false


  let is_constant = function
    | Vint symexp ->
        SymExp.is_constant symexp
    | Vheap symheap ->
        SymHeap.is_constant symheap
    | v ->
        is_const_extern v


  let is_recursive = function Vextern _ | Vexn _ -> true | _ -> false

  let of_intlit intlit = Vint (SymExp.of_intlit intlit)

  let of_float flit = Vint (SymExp.of_float flit)

  let of_symheap sh = Vheap sh

  let of_symexp sexp = Vint sexp

  let get_default_by_typ instr_node typ =
    match Typ.(typ.desc) with
    | Tint _ ->
        zero
    | Tfloat _ ->
        of_float 0.0
    | Tptr _ ->
        make_null ()
    | Tarray _ ->
        L.d_printfln "   - default value of array: extern@." ;
        make_extern instr_node typ
    | _ ->
        L.d_printfln "   - default value of %a: typ@." (Typ.pp_full Pp.text) typ ;
        L.progress "[WARNING]: get default by typ %a@." (Typ.pp_full Pp.text) typ ;
        top


  let proc_neg = Procname.from_string_c_fun "APRVAL_NEG"

  let neg_of = function
    | Vint _ as v ->
        Vextern (proc_neg, [v])
    | Top ->
        Top
    | _ as v ->
        L.(die InternalError) "Could not negate non-integer value %a" pp v


  let proc_lt = Procname.from_string_c_fun "lt"

  let proc_le = Procname.from_string_c_fun "le"

  let make_lt_pred lhs rhs = Vextern (proc_lt, [lhs; rhs])

  let make_le_pred lhs rhs = Vextern (proc_le, [lhs; rhs])

  let add node x y =
    match (x, y) with
    | Vint x, Vint y ->
        Vint (SymExp.add node x y)
    | Vheap x, Vheap y ->
        Vheap (SymHeap.add node x y)
    | _ ->
        Top


  let sub node x y = match (x, y) with Vint x, Vint y -> Vint (SymExp.sub node x y) | _ -> Top

  let mult node x y = match (x, y) with Vint x, Vint y -> Vint (SymExp.mult node x y) | _ -> Top

  let div node x y =
    match (x, y) with
    | Vint x, Vint y -> (
      try Vint (SymExp.div node x y)
      with _ -> to_exn (make_string "java.lang.ArithmeticException") )
    | _ ->
        Top


  let lt node v1 v2 =
    match (v1, v2) with
    | Vint s1, Vint s2 ->
        Vint (SymExp.lt node s1 s2)
    | _ ->
        Vint (SymExp.make_extern node)


  let lte node v1 v2 =
    match (v1, v2) with
    | Vint s1, Vint s2 ->
        Vint (SymExp.lte node s1 s2)
    | _ ->
        Vint (SymExp.make_extern node)


  let is_true x = equal x one

  let is_false x = equal x zero

  let is_symbolic = function
    | Vint symexp ->
        SymExp.is_symbolic symexp
    | Vheap sheap ->
        SymHeap.is_symbolic sheap
    | _ ->
        false


  let is_allocsite = function Vheap sheap -> SymHeap.is_allocsite sheap | _ -> false

  let is_default_const v = is_true v || is_false v || is_null v

  let weak_join lhs rhs =
    match (lhs, rhs) with
    | _, _ when equal lhs rhs ->
        lhs
    | Vint _, _ | _, Vint _ ->
        make_int_extern InstrNode.dummy
    | Vheap _, _ | _, Vheap _ ->
        make_heap_extern InstrNode.dummy
    | Vexn _, _ | _, Vexn _ ->
        exn
    | _ ->
        top


  let join = weak_join

  let widen ~prev ~next ~num_iters:_ = join prev next

  let get_symbol_opt = function Vheap (Symbol s) | Vint (Symbol s) -> Some s | _ -> None

  let symbol_from_loc_opt typ loc =
    let open IOption.Let_syntax in
    let+ symbol = Loc.to_symbol_opt loc in
    if Typ.is_pointer typ then Vheap (SymHeap.of_symbol symbol)
    else if Typ.is_int typ || Typ.is_float typ then Vint (SymExp.of_symbol symbol)
    else top


  let to_loc = function
    | Vheap h ->
        Loc.SymHeap h
    | Top ->
        Loc.SymHeap SymHeap.unknown
    | _ as v ->
        raise
          (Unexpected (F.asprintf "Non-locational value %a cannot be converted to location" pp v))


  let to_symexp node = function
    | Vint s ->
        s
    | Top ->
        SymExp.make_extern node
    | _ as v ->
        raise (Unexpected (F.asprintf "Non-integer value %a cannot be converted to symexp" pp v))


  let to_symheap = function
    | Vheap s ->
        s
    | Top ->
        SymHeap.unknown
    | _ as v ->
        raise (Unexpected (F.asprintf "Non-heap value %a cannot be converted to symheap" pp v))


  let to_ap v =
    match v with
    | Vheap (Null _) ->
        Some AccessExpr.null
    | Vheap (String str) ->
        Some (AccessExpr.of_const (Const.Cstr str))
    | Vheap (Symbol s) ->
        Some (Symbol.to_ap s)
    | Vint (IntLit intlit) ->
        Some (AccessExpr.of_const (Const.Cint intlit))
    | Vint (FloatLit flit) ->
        Some (AccessExpr.of_const (Const.Cfloat flit))
    | Vint (Symbol s) ->
        Some (Symbol.to_ap s)
    | Vint _ when is_const_extern v -> (
      match get_const v with Some c -> Some (AccessExpr.of_const c) | None -> None )
    | Vexn (Vheap (String s)) ->
        Some (AccessExpr.of_exn s)
    | _ ->
        None


  let rec replace_sub (x : t) ~(src : t) ~(dst : t) =
    match (x, dst) with
    | Vextern _, Vextern _ ->
        (* TODO: support only single function *) x
    | Vextern (mthd, args), _ ->
        Vextern (mthd, List.map args ~f:(replace_sub ~src ~dst))
    | Vexn x, Vheap _ ->
        Vexn (replace_sub x ~src ~dst)
    | _ ->
        let equal = if is_null x then equal_up_to_source else equal in
        if equal x src then dst else x


  let rec replace_by_map ~f = function
    | Vextern (mthd, args) ->
        Vextern (mthd, List.map args ~f:(replace_by_map ~f))
    | Vexn v ->
        Vexn (f v)
    | v ->
        f v


  let rec get_subvalues v =
    match v with
    | Vextern (_, args) ->
        v :: List.concat_map args ~f:get_subvalues
    | Vexn vexn ->
        v :: get_subvalues vexn
    | Vint sh ->
        v :: (SymExp.get_sub_symbols sh |> List.map ~f:(fun sh -> Vheap (Symbol sh)))
    | Vheap sh ->
        v :: (SymHeap.get_sub_symbols sh |> List.map ~f:(fun sh -> Vheap sh))
    | _ ->
        [v]


  let rec append_ctx ~offset = function
    | Vint symexp ->
        Vint (SymExp.append_ctx ~offset symexp)
    | Vheap symheap ->
        Vheap (SymHeap.append_ctx ~offset symheap)
    | Vexn v ->
        Vexn (append_ctx ~offset v)
    | Vextern (pname, vlist) ->
        Vextern (pname, List.map ~f:(append_ctx ~offset) vlist)
    | _ as v ->
        v
end

module Val = struct
  include ValCore
  module Set = AbstractDomain.FiniteSet (ValCore)
  module Map = PrettyPrintable.MakePPMap (ValCore)
end

let neg i = if IntLit.iszero i then IntLit.one else IntLit.zero

module PathCond = struct
  include Constraint.Make (Val)

  (* TODO : normalize inequality *)
  let normalize = function
    (* neg(a) == true => a == false *)
    | Eq (Val.Vint (SymExp.IntLit i), Val.Vextern (proc, [v]))
    | Eq (Val.Vextern (proc, [v]), Val.Vint (SymExp.IntLit i))
      when Procname.equal proc Val.proc_neg ->
        (* L.d_printfln "%a == %a(%a) is normalized to %a" IntLit.pp i Procname.pp proc Val.pp v IntLit.pp
           (neg i) ; *)
        Eq (v, Val.Vint (SymExp.IntLit (neg i)))
    (* not (neg (a) == true) => a == true *)
    | Neg (Eq (Val.Vint (SymExp.IntLit i), Val.Vextern (proc, [v])))
    | Neg (Eq (Val.Vextern (proc, [v]), Val.Vint (SymExp.IntLit i)))
      when Procname.equal proc Val.proc_neg ->
        (* L.d_printfln "%a == %a(%a) is normalizable" IntLit.pp i Procname.pp proc Val.pp v ; *)
        Eq (v, Val.Vint (SymExp.IntLit i))
    | _ as pathcond ->
        pathcond
end

module PC = struct
  include Constraint.MakePC (Val)

  let[@warning "-57"] add ?(is_branch = false) pathcond pc =
    let add = add ~is_branch in
    let open PathCond in
    (* TODO: inequality solver *)
    match pathcond with
    | (Eq (Val.Vextern (proc, [lhs; rhs]), truth) | Eq (truth, Val.Vextern (proc, [lhs; rhs])))
      when Procname.equal proc Val.proc_le && Val.equal truth Val.one ->
        let is_lte = Val.lte InstrNode.dummy lhs rhs in
        if Val.is_true is_lte then pc
        else if Val.is_false is_lte then add false_cond pc
        else add pathcond pc |> add (Neg (Eq (Val.make_lt_pred rhs lhs, Val.one)))
    | (Eq (Val.Vextern (proc, [lhs; rhs]), truth) | Eq (truth, Val.Vextern (proc, [lhs; rhs])))
      when Procname.equal proc Val.proc_lt && Val.equal truth Val.one ->
        let is_lt = Val.lt InstrNode.dummy lhs rhs in
        if Val.is_true is_lt then pc
        else if Val.is_false is_lt then add false_cond pc
        else add pathcond pc |> add (Neg (Eq (Val.make_le_pred rhs lhs, Val.one)))
    | _ ->
        add pathcond pc
end

module Reg = struct
  include WeakMap.Make (Ident) (Val)

  let weak_join ~lhs ~rhs = mapi (fun l v -> Val.weak_join v (find l rhs)) lhs
end

module Mem = struct
  (* Allocsite[Index] has null as default value 
   * Other location has bottom as default value *)
  include WeakMap.Make (Loc) (Val)

  let mem l t = Val.is_bottom (find l t) |> not

  let weak_join ~lhs ~rhs ~current_proc =
    (* TODO: what if 
     * l -> v   | l -> bot
     * l -> bot | l -> bot *)
    merge
      (fun _ v_lhs_opt v_rhs_opt ->
        match (v_lhs_opt, v_rhs_opt) with
        | Some v_lhs, Some v_rhs ->
            Some (Val.weak_join v_lhs v_rhs)
        | Some v, None | None, Some v ->
            Some v
        | None, None ->
            None)
      lhs rhs


  let loc_of_val t v = fold (fun l v' acc -> if Val.equal v v' then Some l else acc) t None

  let ap_of_val t v =
    match loc_of_val t v with
    | Some l -> (
      match Loc.to_ap l with Some ap -> Some ap | None -> Val.to_ap v )
    | None ->
        Val.to_ap v

  (* union (fun _ v1 v2 -> if Val.equal v1 v2 then Some v1 else Some (Val.weak_join v1 v2)) lhs rhs *)
end
